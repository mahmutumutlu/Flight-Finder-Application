#include "MultiGraph.h"
#include "Exceptions.h"
#include "IntPair.h"
#include <iostream>
#include <iomanip>
#include <fstream>

//=======================//
// Implemented Functions //
//=======================//
MultiGraph::MultiGraph()
{}

MultiGraph::MultiGraph(const std::string& filePath)
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this function !   //
    // ============================= //
    // Tokens
    std::string tokens[5];
    std::ifstream mapFile(filePath.c_str());

    if(!mapFile.is_open())
    {
        std::cout << "Unable to open " << filePath << std::endl;
        return;
    }

    // Read line by line
    std::string line;
    while (std::getline(mapFile, line))
    {
        // Empty Line Skip
        if(line.empty()) continue;
        // Comment Skip
        if(line[0] == '#') continue;

        // Tokenize the line
        int i = 0;
        std::istringstream stream(line);
        while(stream >> tokens[i]) i++;

        // Single token (Meaning it is a vertex)
        if(i == 1)
        {
            InsertVertex(tokens[0]);
        }
        // Exactly 5 tokens (Meaning it is an edge)
        else if(i == 5)
        {
            // Rename vars for readablity
            const std::string& vertexFromName = tokens[0];
            const std::string& vertexToName = tokens[1];
            const std::string& edgeName = tokens[2];
            float weight0 = static_cast<float>(std::atof(tokens[3].c_str()));
            float weight1 = static_cast<float>(std::atof(tokens[4].c_str()));
            AddEdge(edgeName, vertexFromName, vertexToName,
                    weight0, weight1);
        }
        else std::cerr << "Token Size Mismatch" << std::endl;
    }
}

void MultiGraph::PrintPath(const std::vector<int>& orderedVertexEdgeIndexList,
                           float heuristicWeight,
                           bool sameLine) const
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this file !       //
    // ============================= //

    // Name is too long
    const std::vector<int>& ove = orderedVertexEdgeIndexList;
    // Invalid list
    // At least three items should be available
    if(ove.size() < 3) return;

    // Check vertex and an edge
    for(size_t i = 0; i < orderedVertexEdgeIndexList.size(); i += 2)
    {
        int vertexId = ove[i];
        if(vertexId >= static_cast<int>(vertexList.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "VertexId " << vertexId
                      << " not found!" << std::endl;
            return;
        }


        const GraphVertex& vertex = vertexList[vertexId];
        std::cout << vertex.name;
        if(!sameLine) std::cout << "\n";
        // Only find and print the weight if next is available
        if(i == ove.size() - 1) break;
        int nextVertexId = ove[i + 2];
        if(nextVertexId >= static_cast<int>(vertexList.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "VertexId " << vertexId
                    << " not found!" << std::endl;
            return;
        }

        // Find the edge between these two vertices
        int localEdgeId = ove[i + 1];
        if(localEdgeId >= static_cast<int>(vertex.edges.size()))
        {
            // Return if there is a bad vertex id
            std::cout << "EdgeId " << localEdgeId
                      << " not found in " << vertexId << "!" << std::endl;
            return;
        }

        const GraphEdge& edge = vertex.edges[localEdgeId];

        // Combine with heuristic (linear interpolation)
        float weight = Lerp(edge.weight[0], edge.weight[1],
                            heuristicWeight);

        std::cout << "-" << std::setfill('-')
                  << std::setw(4)
                  << weight << "->";
    }
    // Print endline on the last vertex if same line is set
    if(sameLine) std::cout << "\n";
    // Reset fill value because it "sticks" to the std out
    std::cout << std::setfill(' ');
    std::cout.flush();
}

void MultiGraph::PrintEntireGraph() const
{
    // ============================= //
    // This function is implemented  //
    // Do not edit this function !   //
    // ============================= //
    for(size_t i = 0; i < vertexList.size(); i++)
    {
        const GraphVertex& v = vertexList[i];
        std::cout << v.name << "\n";
        for(size_t j = 0; j < v.edges.size(); j++)
        {
            const GraphEdge& edge = v.edges[j];

            // List the all vertex names and weight
            std::cout << "    -"
                      << std::setfill('-')
                      << std::setw(4) << edge.weight[0]
                      << "-"
                      << std::setw(4) << edge.weight[1]
                      << "-> ";
            std::cout << vertexList[edge.endVertexIndex].name;
            std::cout << " (" << edge.name << ")" << "\n";
        }
    }
    // Reset fill value because it "sticks" to the std out
    std::cout << std::setfill(' ');
    std::cout.flush();
}

//=======================//
//          TODO         //
//=======================//
float MultiGraph::Lerp(float w0, float w1, float alpha)
{
    float beta;
    
    beta = w0 * (1 - alpha) + w1 * alpha;
    /* TODO */
    return beta;
}

void MultiGraph::InsertVertex(const std::string& vertexName)
{
    
    for (GraphVertex v: vertexList){
        
        if (v.name == vertexName) throw DuplicateVertexException(vertexName);
        
    }
    
    GraphVertex newVertex;
    newVertex.name = vertexName;
    vertexList.push_back(newVertex);
    /* TODO */
}

void MultiGraph::RemoveVertex(const std::string& vertexName)
{
    
    int ind = 0;
    
    for (GraphVertex v: vertexList){
        
        if (v.name == vertexName){
            
            for (GraphVertex& ver: vertexList){
                
                int i = 0;
                for (GraphEdge& e: ver.edges){
                    
                    if (e.endVertexIndex > ind) e.endVertexIndex--;
                    
                    else if (e.endVertexIndex == ind)
                    ver.edges.erase(ver.edges.begin() + i);
                    
                }
                
            }
            
            vertexList.erase(vertexList.begin() + ind);
            return;
            
        }
        
        ind++;
    }
    
    throw VertexNotFoundException(vertexName);
    /* TODO */
}

void MultiGraph::AddEdge(const std::string& edgeName,
                         const std::string& vertexFromName,
                         const std::string& vertexToName,
                         float weight0, float weight1)
{
    
    int i = 0, indTo = -1, indFrom = -1;
    
    for (GraphVertex v: vertexList){
        
        if (v.name == vertexFromName) indFrom = i;
        
        else if (v.name == vertexToName) indTo = i;
        
        i++;
        
    }
    
    if (indFrom == -1)
    throw VertexNotFoundException(vertexFromName);
    
    if (indTo == -1)
    throw VertexNotFoundException(vertexToName);
    
    for (GraphEdge e: vertexList[indFrom].edges){
        
        if (e.name == edgeName && e.endVertexIndex == indTo)
        throw SameNamedEdgeException(edgeName, vertexFromName, vertexToName);
        
    }
    
    GraphEdge newEdge;
    
    newEdge.name = edgeName;
    newEdge.weight[0] = weight0;
    newEdge.weight[1] = weight1;
    newEdge.endVertexIndex = indTo;
    
    vertexList[indFrom].edges.push_back(newEdge);
    /* TODO */
}

void MultiGraph::RemoveEdge(const std::string& edgeName,
                            const std::string& vertexFromName,
                            const std::string& vertexToName)
{
    
    int i = 0, indTo = -1, indFrom = -1;
    
    for (GraphVertex v: vertexList){
        
        if (v.name == vertexFromName) indFrom = i;
        
        else if (v.name == vertexToName) indTo = i;
        
        i++;
        
    }
    
    if (indFrom == -1)
    throw VertexNotFoundException(vertexFromName);
    
    if (indTo == -1)
    throw VertexNotFoundException(vertexToName);
    
    i = 0;
    for (GraphEdge e: vertexList[indFrom].edges){
        
        if (e.name == edgeName){
            
            vertexList[indFrom].edges.erase(vertexList[indFrom].edges.begin()+i);
            return;
            
        }
        
        i++;
    }
    
    throw EdgeNotFoundException(vertexFromName, edgeName);
    /* TODO */
}

bool MultiGraph::HeuristicShortestPath(std::vector<int>& orderedVertexEdgeIndexList,
                                       const std::string& vertexNameFrom,
                                       const std::string& vertexNameTo,
                                       float heuristicWeight) const
{
    
    float inf = 9999999.0f;
    int i = 0, indTo = -1, indFrom = -1, ind;
    int size = vertexList.size();
    
    for (GraphVertex v: vertexList){
        
        if (v.name == vertexNameFrom) indFrom = i;
        
        else if (v.name == vertexNameTo) indTo = i;
        
        i++;
        
    }
    
    if (indFrom == -1)
    throw VertexNotFoundException(vertexNameFrom);
    
    if (indTo == -1)
    throw VertexNotFoundException(vertexNameTo);
    
    
    std::vector<bool> marked (size, false);
    std::vector<int> edgeInd (size, -1);
    std::vector<int> vertexInd (size, -1);
    std::vector<float> dist (size, inf);
    
    dist[indFrom] = 0.0f;
    
    ind = indFrom;
    for (int i = 0; i < size; i++) {
        
        if(dist[ind] == inf) break;
        
        marked[ind] = true;
        
        if (marked[indTo]) break;
        
        int t = 0;
        for (GraphEdge e: vertexList[ind].edges){
            
            if (!marked[e.endVertexIndex]){
                
                float newDist = Lerp(e.weight[0], e.weight[1], heuristicWeight);
                
                if (newDist + dist[ind] < dist[e.endVertexIndex]){
                    
                    dist[e.endVertexIndex] = newDist + dist[ind];
                    vertexInd[e.endVertexIndex] = ind;
                    edgeInd[e.endVertexIndex] = t;
                    
                }
            }
            
            t++;
        }
        
        ind = -1;
        for (int j = 0; j < size; j++){
            
            if (marked[j]) continue;
            
            if (ind == -1 || dist[j] < dist[ind]) ind = j;
            
        }
        
    }
    
    if (marked[indTo]){
        
        ind = indTo;
        while (ind != indFrom){
            
            orderedVertexEdgeIndexList.insert(orderedVertexEdgeIndexList.begin(), ind);
            orderedVertexEdgeIndexList.insert(orderedVertexEdgeIndexList.begin(), edgeInd[ind]);
            ind = vertexInd[ind];
            
        }
        
        orderedVertexEdgeIndexList.insert(orderedVertexEdgeIndexList.begin(), indFrom);
        return true;
    }
    /* TODO */
    return false;
}

bool MultiGraph::FilteredShortestPath(std::vector<int>& orderedVertexEdgeIndexList,
                                      const std::string& vertexNameFrom,
                                      const std::string& vertexNameTo,
                                      float heuristicWeight,
                                      const std::vector<std::string>& edgeNames) const
{
    float inf = 9999999.0f;
    int i = 0, indTo = -1, indFrom = -1, ind;
    int size = vertexList.size();
    
    for (GraphVertex v: vertexList){
        
        if (v.name == vertexNameFrom) indFrom = i;
        
        else if (v.name == vertexNameTo) indTo = i;
        
        i++;
        
    }
    
    if (indFrom == -1)
    throw VertexNotFoundException(vertexNameFrom);
    
    if (indTo == -1)
    throw VertexNotFoundException(vertexNameTo);
    
    
    std::vector<bool> marked (size, false);
    std::vector<int> edgeInd (size, -1);
    std::vector<int> vertexInd (size, -1);
    std::vector<float> dist (size, inf);
    
    dist[indFrom] = 0.0f;
    
    //MinPairHeap<int, float> pq;
    
    //for (int i = 0; i < size; i++) pq.push_back(i, dist[i]);
    
    ind = indFrom;
    for (int i = 0; i < size; i++) {
        
        if(dist[ind] == inf) break;
        
        marked[ind] = true;
        
        if (marked[indTo]) break;
        
        int t = -1;
        for (GraphEdge e: vertexList[ind].edges){
            t++;
            
            bool check = false;
            
            for (std::string name: edgeNames){
                
                if (e.name == name){
                    check = true;
                    break;
                }
                
            }
            
            if (check) continue;
            
            if (!marked[e.endVertexIndex]){
                
                float newDist = Lerp(e.weight[0], e.weight[1], heuristicWeight);
                
                if (newDist + dist[ind] < dist[e.endVertexIndex]){
                    
                    dist[e.endVertexIndex] = newDist + dist[ind];
                    vertexInd[e.endVertexIndex] = ind;
                    edgeInd[e.endVertexIndex] = t;
                    
                }
            }
            
        }
        
        ind = -1;
        for (int j = 0; j < size; j++){
            
            if (marked[j]) continue;
            
            if (ind == -1 || dist[j] < dist[ind]) ind = j;
            
        }
        
    }
    
    if (marked[indTo]){
        
        ind = indTo;
        while (ind != indFrom){
            
            orderedVertexEdgeIndexList.insert(orderedVertexEdgeIndexList.begin(), ind);
            orderedVertexEdgeIndexList.insert(orderedVertexEdgeIndexList.begin(), edgeInd[ind]);
            ind = vertexInd[ind];
            
        }
        
        orderedVertexEdgeIndexList.insert(orderedVertexEdgeIndexList.begin(), indFrom);
        return true;
    }
    /* TODO */
    return false;
}

int MultiGraph::BiDirectionalEdgeCount() const
{
    int totalCount = 0, size = vertexList.size();
    
    for (int i = 0; i < size; i++){
        
        for (GraphEdge e1: vertexList[i].edges){
            
            for (GraphEdge e2: vertexList[e1.endVertexIndex].edges){
                
                if (e1.name == e2.name && i == e2.endVertexIndex){
                    totalCount++;
                    break;
                } 
                
            }
            
        }
        
    }
    
    /* TODO */
    return totalCount / 2;
}

int MultiGraph::MaxDepthViaEdgeName(const std::string& vertexName,
                                    const std::string& edgeName) const
{
    int ind = -1, maxDepth = 0;
    int size = vertexList.size();
    int cnt = 0;
    
    for (GraphVertex v: vertexList){
        
        if (v.name == vertexName){
            ind = cnt;
            break;
        } 
        
        cnt++;
        
    }
    
    if (ind == -1) throw VertexNotFoundException(vertexName);
    
    std::vector<bool> marked (size, false);
    std::vector<int> dist (size, -1);
    
    dist[ind] = 0;
    
    for (int i = 0; i < size; i++) {
        
        marked[ind] = true;
        
        for (GraphEdge e: vertexList[ind].edges){
            
            if (e.name == edgeName && !marked[e.endVertexIndex]){
                
                if (dist[e.endVertexIndex] == -1 || 
                    dist[e.endVertexIndex] > dist[ind] + 1)
                dist[e.endVertexIndex] = dist[ind] + 1;
                
            }
            
        }
        
        ind = -1;
        for (int j = 0; j < size; j++){
            
            if (!marked[j] && dist[j] > 0){
                
                if (ind == -1) ind = j;
                
                else if(dist[j] < dist[ind]) ind = j;
                
            }
            
        }
        
        if (ind == -1) break;
    }
    
    for (int i = 0; i < size; i++){
        
        if (dist[i] > maxDepth) maxDepth = dist[i];
        
    }
    
    /* TODO */
    return maxDepth;
}

bool MultiGraph::GetWeights(float& w0,
                            float& w1,
                            const std::string& vertexNameFrom,
                            const std::string& vertexNameTo,
                            const std::string& edgeName) const
{
    int i = 0, indTo = -1, indFrom = -1, ind;
    int size = vertexList.size();
    
    for (GraphVertex v: vertexList){
        
        if (v.name == vertexNameFrom) indFrom = i;
        
        else if (v.name == vertexNameTo) indTo = i;
        
        i++;
        
    }
    
    if (indFrom == -1)
    throw VertexNotFoundException(vertexNameFrom);
    
    if (indTo == -1)
    throw VertexNotFoundException(vertexNameTo);
    
    for (GraphEdge e: vertexList[indFrom].edges){
        
        if (e.name == edgeName && e.endVertexIndex == indTo){
            
            w0 = e.weight[0];
            w1 = e.weight[1];
            
            return true;
        }
        
    }
    
    return false;
}

int MultiGraph::FindVertex(const std::string& vertexName) const
{
    int ind = -1;
    int cnt = 0;
    
    for (GraphVertex v: vertexList){
        
        if (v.name == vertexName){
            ind = cnt;
            break;
        } 
        
        cnt++;
        
    }
    
    return ind;
    
}

int MultiGraph::GetSize() const
{
    return vertexList.size();
}

void MultiGraph::GetEdges(std::vector<GraphEdge>& ed, const int ind) const
{
    ed = vertexList[ind].edges;
}